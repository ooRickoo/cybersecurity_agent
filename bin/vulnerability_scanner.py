#!/usr/bin/env python3
"""
Vulnerability Scanner - Comprehensive Vulnerability Assessment and Management
Provides vulnerability scanning, assessment, and management capabilities for cybersecurity analysis.
"""

import os
import json
import logging
import subprocess
import requests
import time
import re
import socket
import threading
import tempfile
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, List, Any, Optional, Union, Tuple
from dataclasses import dataclass, asdict
from enum import Enum
import ipaddress
import concurrent.futures
from urllib.parse import urlparse

logger = logging.getLogger(__name__)

class VulnerabilitySeverity(Enum):
    """Vulnerability severity levels."""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"

class ScanType(Enum):
    """Types of vulnerability scans."""
    PORT_SCAN = "port_scan"
    SERVICE_SCAN = "service_scan"
    VULNERABILITY_SCAN = "vulnerability_scan"
    WEB_SCAN = "web_scan"
    SSL_SCAN = "ssl_scan"
    COMPREHENSIVE = "comprehensive"

@dataclass
class Vulnerability:
    """Vulnerability information."""
    cve_id: str
    title: str
    description: str
    severity: str
    cvss_score: float
    cvss_vector: str
    affected_products: List[str]
    published_date: str
    last_modified: str
    references: List[str]
    exploit_available: bool
    patch_available: bool
    tags: List[str]

@dataclass
class ScanResult:
    """Vulnerability scan result."""
    target: str
    scan_type: str
    scan_timestamp: str
    scan_duration: float
    vulnerabilities_found: int
    vulnerabilities: List[Vulnerability]
    open_ports: List[int]
    services: Dict[int, str]
    recommendations: List[str]
    risk_score: float
    raw_data: Dict[str, Any]

class VulnerabilityScanner:
    """Comprehensive vulnerability scanning toolkit."""
    
    def __init__(self):
        """Initialize vulnerability scanner."""
        self.logger = logging.getLogger(__name__)
        self.temp_dir = Path(tempfile.gettempdir()) / "vulnerability_scanner"
        self.temp_dir.mkdir(parents=True, exist_ok=True)
        
        # Initialize scanning tools
        self._initialize_tools()
        self._initialize_vulnerability_database()
        
        logger.info("🚀 Vulnerability Scanner initialized")
    
    def _initialize_tools(self):
        """Initialize scanning tools and check availability."""
        self.tools_available = {
            "nmap": self._check_tool_availability("nmap"),
            "masscan": self._check_tool_availability("masscan"),
            "nikto": self._check_tool_availability("nikto"),
            "sslscan": self._check_tool_availability("sslscan"),
            "testssl": self._check_tool_availability("testssl.sh")
        }
        
        logger.info(f"🔧 Tools available: {[k for k, v in self.tools_available.items() if v]}")
    
    def _check_tool_availability(self, tool_name: str) -> bool:
        """Check if a tool is available in the system."""
        try:
            subprocess.run([tool_name, "--version"], 
                         capture_output=True, check=True, timeout=5)
            return True
        except (subprocess.CalledProcessError, FileNotFoundError, subprocess.TimeoutExpired):
            return False
    
    def _initialize_vulnerability_database(self):
        """Initialize vulnerability database with common vulnerabilities."""
        self.vulnerability_db = {
            # Common web vulnerabilities
            "CVE-2021-44228": Vulnerability(
                cve_id="CVE-2021-44228",
                title="Apache Log4j Remote Code Execution",
                description="Apache Log4j2 vulnerable to remote code execution via JNDI lookups",
                severity="critical",
                cvss_score=10.0,
                cvss_vector="CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
                affected_products=["Apache Log4j2"],
                published_date="2021-12-10",
                last_modified="2021-12-10",
                references=["https://nvd.nist.gov/vuln/detail/CVE-2021-44228"],
                exploit_available=True,
                patch_available=True,
                tags=["rce", "log4j", "apache"]
            ),
            "CVE-2021-34527": Vulnerability(
                cve_id="CVE-2021-34527",
                title="Windows Print Spooler Remote Code Execution",
                description="Windows Print Spooler vulnerable to remote code execution",
                severity="critical",
                cvss_score=9.8,
                cvss_vector="CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
                affected_products=["Windows"],
                published_date="2021-07-06",
                last_modified="2021-07-06",
                references=["https://nvd.nist.gov/vuln/detail/CVE-2021-34527"],
                exploit_available=True,
                patch_available=True,
                tags=["rce", "windows", "print-spooler"]
            ),
            # Common SSL/TLS vulnerabilities
            "CVE-2014-0160": Vulnerability(
                cve_id="CVE-2014-0160",
                title="OpenSSL Heartbleed",
                description="OpenSSL vulnerable to information disclosure via heartbeat extension",
                severity="high",
                cvss_score=7.5,
                cvss_vector="CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
                affected_products=["OpenSSL"],
                published_date="2014-04-07",
                last_modified="2014-04-07",
                references=["https://nvd.nist.gov/vuln/detail/CVE-2014-0160"],
                exploit_available=True,
                patch_available=True,
                tags=["ssl", "openssl", "heartbleed"]
            )
        }
    
    def scan_target(self, target: str, scan_type: ScanType = ScanType.COMPREHENSIVE, 
                   ports: List[int] = None, threads: int = 10) -> ScanResult:
        """Perform vulnerability scan on target."""
        start_time = time.time()
        
        try:
            logger.info(f"🔍 Starting {scan_type.value} scan on {target}")
            
            # Validate target
            if not self._validate_target(target):
                raise ValueError(f"Invalid target: {target}")
            
            # Initialize scan result
            result = ScanResult(
                target=target,
                scan_type=scan_type.value,
                scan_timestamp=datetime.now(timezone.utc).isoformat(),
                scan_duration=0.0,
                vulnerabilities_found=0,
                vulnerabilities=[],
                open_ports=[],
                services={},
                recommendations=[],
                risk_score=0.0,
                raw_data={}
            )
            
            # Perform port scan
            if scan_type in [ScanType.PORT_SCAN, ScanType.COMPREHENSIVE]:
                port_scan_result = self._perform_port_scan(target, ports, threads)
                result.open_ports = port_scan_result["open_ports"]
                result.services = port_scan_result["services"]
                result.raw_data["port_scan"] = port_scan_result
            
            # Perform service scan
            if scan_type in [ScanType.SERVICE_SCAN, ScanType.COMPREHENSIVE]:
                service_scan_result = self._perform_service_scan(target, result.open_ports)
                result.services.update(service_scan_result["services"])
                result.raw_data["service_scan"] = service_scan_result
            
            # Perform vulnerability scan
            if scan_type in [ScanType.VULNERABILITY_SCAN, ScanType.COMPREHENSIVE]:
                vuln_scan_result = self._perform_vulnerability_scan(target, result.services)
                result.vulnerabilities = vuln_scan_result["vulnerabilities"]
                result.raw_data["vulnerability_scan"] = vuln_scan_result
            
            # Perform web scan
            if scan_type in [ScanType.WEB_SCAN, ScanType.COMPREHENSIVE]:
                if self._is_web_service(target, result.services):
                    web_scan_result = self._perform_web_scan(target)
                    result.vulnerabilities.extend(web_scan_result["vulnerabilities"])
                    result.raw_data["web_scan"] = web_scan_result
            
            # Perform SSL scan
            if scan_type in [ScanType.SSL_SCAN, ScanType.COMPREHENSIVE]:
                if self._is_ssl_service(target, result.services):
                    ssl_scan_result = self._perform_ssl_scan(target)
                    result.vulnerabilities.extend(ssl_scan_result["vulnerabilities"])
                    result.raw_data["ssl_scan"] = ssl_scan_result
            
            # Calculate risk score
            result.risk_score = self._calculate_risk_score(result)
            result.vulnerabilities_found = len(result.vulnerabilities)
            
            # Generate recommendations
            result.recommendations = self._generate_recommendations(result)
            
            # Calculate scan duration
            result.scan_duration = time.time() - start_time
            
            logger.info(f"✅ Scan completed: {result.vulnerabilities_found} vulnerabilities found")
            
            return result
            
        except Exception as e:
            logger.error(f"❌ Vulnerability scan failed for {target}: {e}")
            raise
    
    def _validate_target(self, target: str) -> bool:
        """Validate scan target."""
        try:
            # Check if it's an IP address
            ipaddress.ip_address(target)
            return True
        except ValueError:
            pass
        
        try:
            # Check if it's a hostname
            socket.gethostbyname(target)
            return True
        except socket.gaierror:
            pass
        
        try:
            # Check if it's a URL
            parsed = urlparse(target)
            if parsed.scheme in ['http', 'https']:
                return True
        except Exception:
            pass
        
        return False
    
    def _perform_port_scan(self, target: str, ports: List[int] = None, threads: int = 10) -> Dict[str, Any]:
        """Perform port scan on target."""
        if ports is None:
            ports = [21, 22, 23, 25, 53, 80, 110, 135, 139, 143, 443, 993, 995, 1433, 1521, 3306, 3389, 5432, 5900, 8080]
        
        open_ports = []
        services = {}
        
        def scan_port(port):
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                result = sock.connect_ex((target, port))
                sock.close()
                
                if result == 0:
                    open_ports.append(port)
                    # Try to identify service
                    service = self._identify_service(target, port)
                    if service:
                        services[port] = service
                    
            except Exception:
                pass
        
        # Use thread pool for concurrent scanning
        with concurrent.futures.ThreadPoolExecutor(max_workers=threads) as executor:
            executor.map(scan_port, ports)
        
        return {
            "open_ports": sorted(open_ports),
            "services": services,
            "total_ports_scanned": len(ports)
        }
    
    def _identify_service(self, target: str, port: int) -> Optional[str]:
        """Identify service running on port."""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(2)
            sock.connect((target, port))
            
            # Send probe and receive response
            if port == 80:
                sock.send(b"GET / HTTP/1.1\r\nHost: " + target.encode() + b"\r\n\r\n")
            elif port == 443:
                sock.send(b"GET / HTTP/1.1\r\nHost: " + target.encode() + b"\r\n\r\n")
            elif port == 22:
                sock.send(b"SSH-2.0-OpenSSH_7.4\r\n")
            elif port == 21:
                sock.send(b"USER anonymous\r\n")
            
            response = sock.recv(1024).decode('utf-8', errors='ignore')
            sock.close()
            
            # Parse response to identify service
            if "HTTP" in response:
                return "HTTP"
            elif "SSH" in response:
                return "SSH"
            elif "FTP" in response:
                return "FTP"
            elif "SMTP" in response:
                return "SMTP"
            elif "POP3" in response:
                return "POP3"
            elif "IMAP" in response:
                return "IMAP"
            elif "MySQL" in response:
                return "MySQL"
            elif "PostgreSQL" in response:
                return "PostgreSQL"
            elif "MSSQL" in response:
                return "MSSQL"
            else:
                return "Unknown"
                
        except Exception:
            return None
    
    def _perform_service_scan(self, target: str, open_ports: List[int]) -> Dict[str, Any]:
        """Perform detailed service scan."""
        services = {}
        
        for port in open_ports:
            service = self._identify_service(target, port)
            if service:
                services[port] = service
        
        return {
            "services": services,
            "ports_scanned": len(open_ports)
        }
    
    def _perform_vulnerability_scan(self, target: str, services: Dict[int, str]) -> Dict[str, Any]:
        """Perform vulnerability scan based on identified services."""
        vulnerabilities = []
        
        # Check for common vulnerabilities based on services
        for port, service in services.items():
            if service == "HTTP":
                # Check for common web vulnerabilities
                web_vulns = self._check_web_vulnerabilities(target, port)
                vulnerabilities.extend(web_vulns)
            
            elif service == "SSH":
                # Check for SSH vulnerabilities
                ssh_vulns = self._check_ssh_vulnerabilities(target, port)
                vulnerabilities.extend(ssh_vulns)
            
            elif service == "FTP":
                # Check for FTP vulnerabilities
                ftp_vulns = self._check_ftp_vulnerabilities(target, port)
                vulnerabilities.extend(ftp_vulns)
        
        return {
            "vulnerabilities": vulnerabilities,
            "services_checked": len(services)
        }
    
    def _check_web_vulnerabilities(self, target: str, port: int) -> List[Vulnerability]:
        """Check for web vulnerabilities."""
        vulnerabilities = []
        
        try:
            # Check for common web vulnerabilities
            url = f"http://{target}:{port}"
            
            # Check for directory traversal
            test_paths = ["../", "..\\", "/etc/passwd", "\\windows\\system32\\drivers\\etc\\hosts"]
            for path in test_paths:
                try:
                    response = requests.get(f"{url}/{path}", timeout=5)
                    if response.status_code == 200 and ("root:" in response.text or "localhost" in response.text):
                        vulnerabilities.append(Vulnerability(
                            cve_id="CVE-DIRECTORY-TRAVERSAL",
                            title="Directory Traversal Vulnerability",
                            description="Web application vulnerable to directory traversal attacks",
                            severity="high",
                            cvss_score=7.5,
                            cvss_vector="CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
                            affected_products=["Web Application"],
                            published_date=datetime.now().strftime("%Y-%m-%d"),
                            last_modified=datetime.now().strftime("%Y-%m-%d"),
                            references=[],
                            exploit_available=True,
                            patch_available=True,
                            tags=["directory-traversal", "web"]
                        ))
                        break
                except Exception:
                    pass
            
            # Check for SQL injection
            sql_payloads = ["'", "\"", "1' OR '1'='1", "1\" OR \"1\"=\"1"]
            for payload in sql_payloads:
                try:
                    response = requests.get(f"{url}/?id={payload}", timeout=5)
                    if "error" in response.text.lower() and ("sql" in response.text.lower() or "mysql" in response.text.lower()):
                        vulnerabilities.append(Vulnerability(
                            cve_id="CVE-SQL-INJECTION",
                            title="SQL Injection Vulnerability",
                            description="Web application vulnerable to SQL injection attacks",
                            severity="critical",
                            cvss_score=9.8,
                            cvss_vector="CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
                            affected_products=["Web Application"],
                            published_date=datetime.now().strftime("%Y-%m-%d"),
                            last_modified=datetime.now().strftime("%Y-%m-%d"),
                            references=[],
                            exploit_available=True,
                            patch_available=True,
                            tags=["sql-injection", "web"]
                        ))
                        break
                except Exception:
                    pass
                    
        except Exception as e:
            logger.error(f"❌ Web vulnerability check failed: {e}")
        
        return vulnerabilities
    
    def _check_ssh_vulnerabilities(self, target: str, port: int) -> List[Vulnerability]:
        """Check for SSH vulnerabilities."""
        vulnerabilities = []
        
        try:
            # Check for weak SSH configurations
            # This is a simplified check - in practice, you'd use tools like ssh-audit
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            sock.connect((target, port))
            
            # Send SSH banner
            sock.send(b"SSH-2.0-OpenSSH_7.4\r\n")
            response = sock.recv(1024).decode('utf-8', errors='ignore')
            sock.close()
            
            # Check for weak SSH versions
            if "SSH-1.99" in response or "SSH-1.5" in response:
                vulnerabilities.append(Vulnerability(
                    cve_id="CVE-SSH-WEAK-VERSION",
                    title="Weak SSH Version",
                    description="SSH service running weak or outdated version",
                    severity="medium",
                    cvss_score=5.3,
                    cvss_vector="CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N",
                    affected_products=["SSH"],
                    published_date=datetime.now().strftime("%Y-%m-%d"),
                    last_modified=datetime.now().strftime("%Y-%m-%d"),
                    references=[],
                    exploit_available=False,
                    patch_available=True,
                    tags=["ssh", "weak-version"]
                ))
                
        except Exception as e:
            logger.error(f"❌ SSH vulnerability check failed: {e}")
        
        return vulnerabilities
    
    def _check_ftp_vulnerabilities(self, target: str, port: int) -> List[Vulnerability]:
        """Check for FTP vulnerabilities."""
        vulnerabilities = []
        
        try:
            # Check for anonymous FTP access
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            sock.connect((target, port))
            
            # Receive banner
            banner = sock.recv(1024).decode('utf-8', errors='ignore')
            
            # Send anonymous login
            sock.send(b"USER anonymous\r\n")
            response = sock.recv(1024).decode('utf-8', errors='ignore')
            
            if "230" in response:  # Login successful
                vulnerabilities.append(Vulnerability(
                    cve_id="CVE-FTP-ANONYMOUS",
                    title="Anonymous FTP Access",
                    description="FTP service allows anonymous access",
                    severity="medium",
                    cvss_score=5.3,
                    cvss_vector="CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N",
                    affected_products=["FTP"],
                    published_date=datetime.now().strftime("%Y-%m-%d"),
                    last_modified=datetime.now().strftime("%Y-%m-%d"),
                    references=[],
                    exploit_available=False,
                    patch_available=True,
                    tags=["ftp", "anonymous-access"]
                ))
            
            sock.close()
            
        except Exception as e:
            logger.error(f"❌ FTP vulnerability check failed: {e}")
        
        return vulnerabilities
    
    def _perform_web_scan(self, target: str) -> Dict[str, Any]:
        """Perform web vulnerability scan."""
        vulnerabilities = []
        
        try:
            # Use nikto if available
            if self.tools_available["nikto"]:
                nikto_result = self._run_nikto_scan(target)
                vulnerabilities.extend(nikto_result["vulnerabilities"])
            
            # Check for common web vulnerabilities
            web_vulns = self._check_web_vulnerabilities(target, 80)
            vulnerabilities.extend(web_vulns)
            
        except Exception as e:
            logger.error(f"❌ Web scan failed: {e}")
        
        return {
            "vulnerabilities": vulnerabilities,
            "scan_type": "web"
        }
    
    def _run_nikto_scan(self, target: str) -> Dict[str, Any]:
        """Run nikto web vulnerability scanner."""
        vulnerabilities = []
        
        try:
            # Run nikto scan
            cmd = ["nikto", "-h", target, "-Format", "json"]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            
            if result.returncode == 0:
                # Parse nikto output
                # This is a simplified parser - in practice, you'd parse the full JSON output
                if "OSVDB" in result.stdout:
                    vulnerabilities.append(Vulnerability(
                        cve_id="NIKTO-FINDING",
                        title="Web Vulnerability Found",
                        description="Nikto identified potential web vulnerabilities",
                        severity="medium",
                        cvss_score=6.5,
                        cvss_vector="CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N",
                        affected_products=["Web Application"],
                        published_date=datetime.now().strftime("%Y-%m-%d"),
                        last_modified=datetime.now().strftime("%Y-%m-%d"),
                        references=[],
                        exploit_available=False,
                        patch_available=True,
                        tags=["web", "nikto"]
                    ))
            
        except Exception as e:
            logger.error(f"❌ Nikto scan failed: {e}")
        
        return {
            "vulnerabilities": vulnerabilities,
            "tool": "nikto"
        }
    
    def _perform_ssl_scan(self, target: str) -> Dict[str, Any]:
        """Perform SSL/TLS vulnerability scan."""
        vulnerabilities = []
        
        try:
            # Check for SSL/TLS vulnerabilities
            ssl_vulns = self._check_ssl_vulnerabilities(target)
            vulnerabilities.extend(ssl_vulns)
            
        except Exception as e:
            logger.error(f"❌ SSL scan failed: {e}")
        
        return {
            "vulnerabilities": vulnerabilities,
            "scan_type": "ssl"
        }
    
    def _check_ssl_vulnerabilities(self, target: str) -> List[Vulnerability]:
        """Check for SSL/TLS vulnerabilities."""
        vulnerabilities = []
        
        try:
            import ssl
            import socket
            
            # Check SSL/TLS configuration
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            with socket.create_connection((target, 443), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=target) as ssock:
                    # Get certificate info
                    cert = ssock.getpeercert()
                    cipher = ssock.cipher()
                    
                    # Check for weak ciphers
                    if cipher and cipher[0] in ['RC4', 'DES', '3DES']:
                        vulnerabilities.append(Vulnerability(
                            cve_id="CVE-SSL-WEAK-CIPHER",
                            title="Weak SSL/TLS Cipher",
                            description="SSL/TLS service uses weak encryption cipher",
                            severity="medium",
                            cvss_score=5.3,
                            cvss_vector="CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N",
                            affected_products=["SSL/TLS"],
                            published_date=datetime.now().strftime("%Y-%m-%d"),
                            last_modified=datetime.now().strftime("%Y-%m-%d"),
                            references=[],
                            exploit_available=False,
                            patch_available=True,
                            tags=["ssl", "weak-cipher"]
                        ))
                    
                    # Check for weak protocols
                    if cipher and cipher[1] in ['TLSv1', 'TLSv1.1']:
                        vulnerabilities.append(Vulnerability(
                            cve_id="CVE-SSL-WEAK-PROTOCOL",
                            title="Weak SSL/TLS Protocol",
                            description="SSL/TLS service uses weak protocol version",
                            severity="medium",
                            cvss_score=5.3,
                            cvss_vector="CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N",
                            affected_products=["SSL/TLS"],
                            published_date=datetime.now().strftime("%Y-%m-%d"),
                            last_modified=datetime.now().strftime("%Y-%m-%d"),
                            references=[],
                            exploit_available=False,
                            patch_available=True,
                            tags=["ssl", "weak-protocol"]
                        ))
                    
        except Exception as e:
            logger.error(f"❌ SSL vulnerability check failed: {e}")
        
        return vulnerabilities
    
    def _is_web_service(self, target: str, services: Dict[int, str]) -> bool:
        """Check if target has web services."""
        return any(service in ["HTTP", "HTTPS"] for service in services.values())
    
    def _is_ssl_service(self, target: str, services: Dict[int, str]) -> bool:
        """Check if target has SSL services."""
        return any(port in services and services[port] in ["HTTPS", "SMTPS", "IMAPS", "POP3S"] 
                  for port in [443, 465, 993, 995])
    
    def _calculate_risk_score(self, result: ScanResult) -> float:
        """Calculate overall risk score."""
        risk_score = 0.0
        
        # Base risk from open ports
        risk_score += len(result.open_ports) * 0.1
        
        # Risk from vulnerabilities
        for vuln in result.vulnerabilities:
            if vuln.severity == "critical":
                risk_score += 1.0
            elif vuln.severity == "high":
                risk_score += 0.8
            elif vuln.severity == "medium":
                risk_score += 0.5
            elif vuln.severity == "low":
                risk_score += 0.2
        
        return min(risk_score, 10.0)
    
    def _generate_recommendations(self, result: ScanResult) -> List[str]:
        """Generate security recommendations."""
        recommendations = []
        
        # General recommendations
        if result.open_ports:
            recommendations.append("Close unnecessary open ports")
            recommendations.append("Implement firewall rules to restrict access")
        
        # Vulnerability-specific recommendations
        for vuln in result.vulnerabilities:
            if vuln.severity in ["critical", "high"]:
                recommendations.append(f"Immediately patch {vuln.cve_id}: {vuln.title}")
            
            if vuln.exploit_available:
                recommendations.append(f"Monitor for exploitation attempts of {vuln.cve_id}")
        
        # Service-specific recommendations
        if "HTTP" in result.services.values():
            recommendations.append("Implement web application firewall")
            recommendations.append("Regularly update web server software")
        
        if "SSH" in result.services.values():
            recommendations.append("Disable SSH root login")
            recommendations.append("Use key-based authentication for SSH")
        
        if "FTP" in result.services.values():
            recommendations.append("Disable anonymous FTP access")
            recommendations.append("Use SFTP instead of FTP")
        
        return recommendations
    
    def scan_network(self, network: str, scan_type: ScanType = ScanType.PORT_SCAN, 
                    threads: int = 50) -> List[ScanResult]:
        """Scan entire network for vulnerabilities."""
        try:
            # Parse network range
            network_obj = ipaddress.ip_network(network, strict=False)
            hosts = list(network_obj.hosts())
            
            logger.info(f"🔍 Scanning {len(hosts)} hosts in network {network}")
            
            results = []
            
            # Use thread pool for concurrent scanning
            with concurrent.futures.ThreadPoolExecutor(max_workers=threads) as executor:
                future_to_host = {
                    executor.submit(self.scan_target, str(host), scan_type): str(host) 
                    for host in hosts
                }
                
                for future in concurrent.futures.as_completed(future_to_host):
                    host = future_to_host[future]
                    try:
                        result = future.result()
                        results.append(result)
                        
                        if result.vulnerabilities_found > 0:
                            logger.warning(f"⚠️ Vulnerabilities found on {host}: {result.vulnerabilities_found}")
                        
                    except Exception as e:
                        logger.error(f"❌ Scan failed for {host}: {e}")
            
            # Summary
            total_vulns = sum(r.vulnerabilities_found for r in results)
            hosts_with_vulns = sum(1 for r in results if r.vulnerabilities_found > 0)
            
            logger.info(f"✅ Network scan complete: {hosts_with_vulns}/{len(results)} hosts have vulnerabilities")
            logger.info(f"   Total vulnerabilities found: {total_vulns}")
            
            return results
            
        except Exception as e:
            logger.error(f"❌ Network scan failed: {e}")
            raise
    
    def export_results(self, results: List[ScanResult], output_path: str, format: str = "json") -> bool:
        """Export scan results to file."""
        try:
            output_path = Path(output_path)
            output_path.parent.mkdir(parents=True, exist_ok=True)
            
            if format.lower() == "json":
                # Export as JSON
                export_data = []
                for result in results:
                    export_data.append({
                        "target": result.target,
                        "scan_type": result.scan_type,
                        "scan_timestamp": result.scan_timestamp,
                        "scan_duration": result.scan_duration,
                        "vulnerabilities_found": result.vulnerabilities_found,
                        "risk_score": result.risk_score,
                        "open_ports": result.open_ports,
                        "services": result.services,
                        "vulnerabilities": [asdict(v) for v in result.vulnerabilities],
                        "recommendations": result.recommendations
                    })
                
                with open(output_path, 'w') as f:
                    json.dump(export_data, f, indent=2)
            
            elif format.lower() == "csv":
                # Export as CSV
                import csv
                with open(output_path, 'w', newline='') as f:
                    writer = csv.writer(f)
                    writer.writerow([
                        "Target", "Scan Type", "Timestamp", "Duration", 
                        "Vulnerabilities", "Risk Score", "Open Ports", "Services"
                    ])
                    
                    for result in results:
                        writer.writerow([
                            result.target,
                            result.scan_type,
                            result.scan_timestamp,
                            result.scan_duration,
                            result.vulnerabilities_found,
                            result.risk_score,
                            ",".join(map(str, result.open_ports)),
                            ",".join([f"{k}:{v}" for k, v in result.services.items()])
                        ])
            
            else:
                raise ValueError(f"Unsupported export format: {format}")
            
            logger.info(f"✅ Results exported to {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"❌ Export failed: {e}")
            return False
    
    def cleanup(self):
        """Clean up temporary files."""
        try:
            if self.temp_dir.exists():
                import shutil
                shutil.rmtree(self.temp_dir)
                logger.info("✅ Cleaned up vulnerability scanner temporary files")
        except Exception as e:
            logger.error(f"❌ Failed to cleanup: {e}")

# Example usage and testing
if __name__ == "__main__":
    # Test the vulnerability scanner
    vs = VulnerabilityScanner()
    
    try:
        # Test single host scan
        result = vs.scan_target("127.0.0.1", ScanType.PORT_SCAN)
        print(f"✅ Scan completed: {result.vulnerabilities_found} vulnerabilities found")
        print(f"   Open ports: {result.open_ports}")
        print(f"   Services: {result.services}")
        print(f"   Risk score: {result.risk_score}")
        
        # Export results
        vs.export_results([result], "vulnerability_scan_results.json")
        print("✅ Results exported")
        
    finally:
        vs.cleanup()
