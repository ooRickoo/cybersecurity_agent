#!/usr/bin/env python3
"""
Malware Analysis Tools - Comprehensive Malware Detection and Analysis
Provides advanced malware analysis capabilities for cybersecurity investigations.
"""

import os
import hashlib
import json
import logging
import subprocess
import tempfile
import time
import re
import struct
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, List, Any, Optional, Union, Tuple, BinaryIO
from dataclasses import dataclass, asdict
from enum import Enum
import pefile
import yara
import requests
from urllib.parse import quote

logger = logging.getLogger(__name__)

class MalwareType(Enum):
    """Malware type classifications."""
    TROJAN = "trojan"
    VIRUS = "virus"
    WORM = "worm"
    RANSOMWARE = "ransomware"
    SPYWARE = "spyware"
    ADWARE = "adware"
    ROOTKIT = "rootkit"
    BACKDOOR = "backdoor"
    KEYLOGGER = "keylogger"
    BOTNET = "botnet"
    UNKNOWN = "unknown"

class ThreatLevel(Enum):
    """Threat level classifications."""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

@dataclass
class MalwareSignature:
    """Malware signature information."""
    name: str
    malware_type: str
    threat_level: str
    description: str
    indicators: List[str]
    yara_rule: str
    source: str
    confidence: float

@dataclass
class MalwareAnalysisResult:
    """Malware analysis result."""
    file_path: str
    file_hash: str
    analysis_timestamp: str
    analysis_duration: float
    malware_detected: bool
    malware_type: str
    threat_level: str
    confidence_score: float
    signatures_matched: List[MalwareSignature]
    behavioral_indicators: List[str]
    network_indicators: List[str]
    file_indicators: List[str]
    registry_indicators: List[str]
    recommendations: List[str]
    raw_analysis: Dict[str, Any]

class MalwareAnalysisTools:
    """Comprehensive malware analysis toolkit."""
    
    def __init__(self):
        """Initialize malware analysis tools."""
        self.logger = logging.getLogger(__name__)
        self.temp_dir = Path(tempfile.gettempdir()) / "malware_analysis"
        self.temp_dir.mkdir(parents=True, exist_ok=True)
        
        # Initialize analysis engines
        self._initialize_yara()
        self._initialize_signatures()
        self._initialize_behavioral_patterns()
        
        logger.info("🚀 Malware Analysis Tools initialized")
    
    def _initialize_yara(self):
        """Initialize YARA rule engine."""
        try:
            # Create default YARA rules directory
            self.yara_rules_dir = self.temp_dir / "yara_rules"
            self.yara_rules_dir.mkdir(exist_ok=True)
            
            # Create basic YARA rules
            self._create_basic_yara_rules()
            
            # Compile YARA rules
            self.yara_rules = yara.compile(str(self.yara_rules_dir / "*.yar"))
            
            logger.info("✅ YARA rules initialized")
            
        except Exception as e:
            logger.warning(f"⚠️ YARA initialization failed: {e}")
            self.yara_rules = None
    
    def _create_basic_yara_rules(self):
        """Create basic YARA rules for common malware patterns."""
        basic_rules = [
            {
                "name": "suspicious_strings",
                "rule": """
rule SuspiciousStrings {
    meta:
        description = "Detects suspicious strings commonly found in malware"
        author = "Cybersecurity Agent"
        date = "2024-01-01"
    
    strings:
        $s1 = "cmd.exe" nocase
        $s2 = "powershell" nocase
        $s3 = "regsvr32" nocase
        $s4 = "rundll32" nocase
        $s5 = "wscript" nocase
        $s6 = "cscript" nocase
        $s7 = "download" nocase
        $s8 = "execute" nocase
        $s9 = "payload" nocase
        $s10 = "backdoor" nocase
    
    condition:
        3 of them
}
""",
                "file": "suspicious_strings.yar"
            },
            {
                "name": "packed_executable",
                "rule": """
rule PackedExecutable {
    meta:
        description = "Detects packed or obfuscated executables"
        author = "Cybersecurity Agent"
        date = "2024-01-01"
    
    strings:
        $s1 = "UPX" nocase
        $s2 = "ASPack" nocase
        $s3 = "PECompact" nocase
        $s4 = "Themida" nocase
        $s5 = "VMProtect" nocase
    
    condition:
        1 of them
}
""",
                "file": "packed_executable.yar"
            },
            {
                "name": "network_activity",
                "rule": """
rule NetworkActivity {
    meta:
        description = "Detects network-related malware behavior"
        author = "Cybersecurity Agent"
        date = "2024-01-01"
    
    strings:
        $s1 = "http://" nocase
        $s2 = "https://" nocase
        $s3 = "ftp://" nocase
        $s4 = "tcp://" nocase
        $s5 = "socket" nocase
        $s6 = "connect" nocase
        $s7 = "send" nocase
        $s8 = "recv" nocase
    
    condition:
        3 of them
}
""",
                "file": "network_activity.yar"
            }
        ]
        
        for rule_data in basic_rules:
            rule_file = self.yara_rules_dir / rule_data["file"]
            with open(rule_file, 'w') as f:
                f.write(rule_data["rule"])
    
    def _initialize_signatures(self):
        """Initialize malware signatures database."""
        self.malware_signatures = [
            MalwareSignature(
                name="Generic Trojan",
                malware_type="trojan",
                threat_level="high",
                description="Generic trojan horse detection",
                indicators=["cmd.exe", "powershell", "download", "execute"],
                yara_rule="suspicious_strings",
                source="internal",
                confidence=0.7
            ),
            MalwareSignature(
                name="Packed Executable",
                malware_type="unknown",
                threat_level="medium",
                description="Detects packed or obfuscated executables",
                indicators=["UPX", "ASPack", "PECompact"],
                yara_rule="packed_executable",
                source="internal",
                confidence=0.8
            ),
            MalwareSignature(
                name="Network Malware",
                malware_type="backdoor",
                threat_level="high",
                description="Malware with network communication capabilities",
                indicators=["http://", "socket", "connect", "send"],
                yara_rule="network_activity",
                source="internal",
                confidence=0.6
            )
        ]
    
    def _initialize_behavioral_patterns(self):
        """Initialize behavioral analysis patterns."""
        self.behavioral_patterns = {
            "file_operations": [
                "CreateFile", "WriteFile", "DeleteFile", "MoveFile", "CopyFile"
            ],
            "registry_operations": [
                "RegCreateKey", "RegSetValue", "RegDeleteKey", "RegDeleteValue"
            ],
            "network_operations": [
                "socket", "connect", "send", "recv", "bind", "listen"
            ],
            "process_operations": [
                "CreateProcess", "TerminateProcess", "OpenProcess", "WriteProcessMemory"
            ],
            "suspicious_apis": [
                "VirtualAlloc", "VirtualProtect", "CreateRemoteThread", "SetWindowsHookEx"
            ]
        }
    
    def analyze_file(self, file_path: Union[str, Path]) -> MalwareAnalysisResult:
        """Perform comprehensive malware analysis on a file."""
        start_time = time.time()
        
        try:
            file_path = Path(file_path)
            
            if not file_path.exists():
                raise FileNotFoundError(f"File not found: {file_path}")
            
            # Calculate file hash
            file_hash = self._calculate_file_hash(file_path)
            
            # Initialize result
            result = MalwareAnalysisResult(
                file_path=str(file_path.absolute()),
                file_hash=file_hash,
                analysis_timestamp=datetime.now(timezone.utc).isoformat(),
                analysis_duration=0.0,
                malware_detected=False,
                malware_type="unknown",
                threat_level="low",
                confidence_score=0.0,
                signatures_matched=[],
                behavioral_indicators=[],
                network_indicators=[],
                file_indicators=[],
                registry_indicators=[],
                recommendations=[],
                raw_analysis={}
            )
            
            # Perform static analysis
            static_analysis = self._perform_static_analysis(file_path)
            result.raw_analysis["static"] = static_analysis
            
            # Perform YARA scanning
            yara_matches = self._perform_yara_scan(file_path)
            result.raw_analysis["yara"] = yara_matches
            
            # Perform PE analysis (if executable)
            if file_path.suffix.lower() in ['.exe', '.dll', '.sys']:
                pe_analysis = self._perform_pe_analysis(file_path)
                result.raw_analysis["pe"] = pe_analysis
            
            # Perform string analysis
            string_analysis = self._perform_string_analysis(file_path)
            result.raw_analysis["strings"] = string_analysis
            
            # Analyze behavioral indicators
            behavioral_analysis = self._analyze_behavioral_indicators(file_path)
            result.behavioral_indicators = behavioral_analysis["indicators"]
            result.network_indicators = behavioral_analysis["network"]
            result.file_indicators = behavioral_analysis["file"]
            result.registry_indicators = behavioral_analysis["registry"]
            
            # Determine malware classification
            classification = self._classify_malware(result.raw_analysis, yara_matches)
            result.malware_detected = classification["detected"]
            result.malware_type = classification["type"]
            result.threat_level = classification["threat_level"]
            result.confidence_score = classification["confidence"]
            result.signatures_matched = classification["signatures"]
            
            # Generate recommendations
            result.recommendations = self._generate_recommendations(result)
            
            # Calculate analysis duration
            result.analysis_duration = time.time() - start_time
            
            logger.info(f"✅ Malware analysis completed for {file_path.name}: {result.malware_detected}")
            
            return result
            
        except Exception as e:
            logger.error(f"❌ Malware analysis failed for {file_path}: {e}")
            raise
    
    def _calculate_file_hash(self, file_path: Path) -> str:
        """Calculate SHA256 hash of file."""
        sha256_hash = hashlib.sha256()
        with open(file_path, "rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                sha256_hash.update(chunk)
        return sha256_hash.hexdigest()
    
    def _perform_static_analysis(self, file_path: Path) -> Dict[str, Any]:
        """Perform static analysis on file."""
        analysis = {
            "file_size": file_path.stat().st_size,
            "entropy": self._calculate_entropy(file_path),
            "magic_bytes": self._get_magic_bytes(file_path),
            "suspicious_sections": [],
            "imports": [],
            "exports": [],
            "resources": []
        }
        
        # Check for suspicious characteristics
        if analysis["entropy"] > 7.5:
            analysis["suspicious_sections"].append("High entropy - possibly packed/encrypted")
        
        return analysis
    
    def _calculate_entropy(self, file_path: Path) -> float:
        """Calculate file entropy."""
        try:
            with open(file_path, 'rb') as f:
                data = f.read()
            
            if not data:
                return 0.0
            
            # Count byte frequencies
            byte_counts = [0] * 256
            for byte in data:
                byte_counts[byte] += 1
            
            # Calculate entropy
            entropy = 0.0
            data_len = len(data)
            
            for count in byte_counts:
                if count > 0:
                    probability = count / data_len
                    entropy -= probability * (probability.bit_length() - 1)
            
            return entropy
            
        except Exception:
            return 0.0
    
    def _get_magic_bytes(self, file_path: Path) -> str:
        """Get file magic bytes."""
        try:
            with open(file_path, 'rb') as f:
                magic_bytes = f.read(16)
            return magic_bytes.hex()
        except Exception:
            return ""
    
    def _perform_yara_scan(self, file_path: Path) -> List[Dict[str, Any]]:
        """Perform YARA rule scanning."""
        matches = []
        
        if not self.yara_rules:
            return matches
        
        try:
            yara_matches = self.yara_rules.match(str(file_path))
            
            for match in yara_matches:
                matches.append({
                    "rule_name": match.rule,
                    "tags": match.tags,
                    "meta": match.meta,
                    "strings": [str(s) for s in match.strings]
                })
                
        except Exception as e:
            logger.error(f"❌ YARA scan failed: {e}")
        
        return matches
    
    def _perform_pe_analysis(self, file_path: Path) -> Dict[str, Any]:
        """Perform PE file analysis."""
        analysis = {
            "is_pe": False,
            "architecture": None,
            "sections": [],
            "imports": [],
            "exports": [],
            "resources": [],
            "suspicious_characteristics": []
        }
        
        try:
            pe = pefile.PE(str(file_path))
            analysis["is_pe"] = True
            analysis["architecture"] = pe.FILE_HEADER.Machine
            
            # Analyze sections
            for section in pe.sections:
                section_info = {
                    "name": section.Name.decode('utf-8', errors='ignore').rstrip('\x00'),
                    "virtual_address": hex(section.VirtualAddress),
                    "virtual_size": section.Misc_VirtualSize,
                    "raw_size": section.SizeOfRawData,
                    "characteristics": hex(section.Characteristics)
                }
                analysis["sections"].append(section_info)
                
                # Check for suspicious section characteristics
                if section.Characteristics & 0x20000000:  # IMAGE_SCN_MEM_EXECUTE
                    analysis["suspicious_characteristics"].append("Executable section found")
            
            # Analyze imports
            if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
                for entry in pe.DIRECTORY_ENTRY_IMPORT:
                    dll_name = entry.dll.decode('utf-8', errors='ignore')
                    imports = []
                    for imp in entry.imports:
                        if imp.name:
                            imports.append(imp.name.decode('utf-8', errors='ignore'))
                    analysis["imports"].append({"dll": dll_name, "functions": imports})
            
            # Analyze exports
            if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
                for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:
                    if exp.name:
                        analysis["exports"].append(exp.name.decode('utf-8', errors='ignore'))
            
            pe.close()
            
        except Exception as e:
            logger.error(f"❌ PE analysis failed: {e}")
            analysis["error"] = str(e)
        
        return analysis
    
    def _perform_string_analysis(self, file_path: Path) -> Dict[str, Any]:
        """Perform string analysis on file."""
        analysis = {
            "suspicious_strings": [],
            "urls": [],
            "ips": [],
            "emails": [],
            "file_paths": [],
            "registry_keys": []
        }
        
        try:
            with open(file_path, 'rb') as f:
                data = f.read()
            
            # Extract printable strings
            strings = re.findall(b'[\x20-\x7E]{4,}', data)
            
            for string in strings:
                string_str = string.decode('utf-8', errors='ignore')
                
                # Check for suspicious strings
                suspicious_patterns = [
                    r'cmd\.exe', r'powershell', r'regsvr32', r'rundll32',
                    r'wscript', r'cscript', r'download', r'execute',
                    r'payload', r'backdoor', r'trojan', r'keylogger'
                ]
                
                for pattern in suspicious_patterns:
                    if re.search(pattern, string_str, re.IGNORECASE):
                        analysis["suspicious_strings"].append(string_str)
                        break
                
                # Extract URLs
                url_pattern = r'https?://[^\s<>"{}|\\^`\[\]]+'
                urls = re.findall(url_pattern, string_str)
                analysis["urls"].extend(urls)
                
                # Extract IP addresses
                ip_pattern = r'\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b'
                ips = re.findall(ip_pattern, string_str)
                analysis["ips"].extend(ips)
                
                # Extract email addresses
                email_pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
                emails = re.findall(email_pattern, string_str)
                analysis["emails"].extend(emails)
                
                # Extract file paths
                path_pattern = r'[A-Za-z]:\\[^<>:"|?*]*'
                paths = re.findall(path_pattern, string_str)
                analysis["file_paths"].extend(paths)
                
                # Extract registry keys
                registry_pattern = r'HKEY_[A-Z_]+\\[^<>:"|?*]*'
                registry_keys = re.findall(registry_pattern, string_str)
                analysis["registry_keys"].extend(registry_keys)
            
            # Remove duplicates
            for key in analysis:
                if isinstance(analysis[key], list):
                    analysis[key] = list(set(analysis[key]))
            
        except Exception as e:
            logger.error(f"❌ String analysis failed: {e}")
            analysis["error"] = str(e)
        
        return analysis
    
    def _analyze_behavioral_indicators(self, file_path: Path) -> Dict[str, List[str]]:
        """Analyze behavioral indicators from static analysis."""
        indicators = {
            "indicators": [],
            "network": [],
            "file": [],
            "registry": []
        }
        
        try:
            # Read file content for pattern matching
            with open(file_path, 'rb') as f:
                content = f.read()
            
            content_str = content.decode('utf-8', errors='ignore')
            
            # Check for behavioral patterns
            for category, patterns in self.behavioral_patterns.items():
                for pattern in patterns:
                    if pattern.lower() in content_str.lower():
                        indicators["indicators"].append(f"{category}: {pattern}")
                        
                        # Categorize specific indicators
                        if category == "network_operations":
                            indicators["network"].append(pattern)
                        elif category == "file_operations":
                            indicators["file"].append(pattern)
                        elif category == "registry_operations":
                            indicators["registry"].append(pattern)
            
        except Exception as e:
            logger.error(f"❌ Behavioral analysis failed: {e}")
        
        return indicators
    
    def _classify_malware(self, raw_analysis: Dict[str, Any], yara_matches: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Classify malware based on analysis results."""
        classification = {
            "detected": False,
            "type": "unknown",
            "threat_level": "low",
            "confidence": 0.0,
            "signatures": []
        }
        
        confidence_score = 0.0
        threat_indicators = 0
        
        # Check YARA matches
        if yara_matches:
            classification["detected"] = True
            confidence_score += 0.3
            threat_indicators += 1
            
            for match in yara_matches:
                # Find matching signature
                for signature in self.malware_signatures:
                    if signature.yara_rule == match["rule_name"]:
                        classification["signatures"].append(signature)
                        break
        
        # Check static analysis results
        static = raw_analysis.get("static", {})
        if static.get("entropy", 0) > 7.5:
            confidence_score += 0.2
            threat_indicators += 1
        
        # Check string analysis
        strings = raw_analysis.get("strings", {})
        if strings.get("suspicious_strings"):
            confidence_score += 0.2
            threat_indicators += 1
            classification["detected"] = True
        
        if strings.get("urls") or strings.get("ips"):
            confidence_score += 0.1
            threat_indicators += 1
        
        # Check PE analysis
        pe = raw_analysis.get("pe", {})
        if pe.get("suspicious_characteristics"):
            confidence_score += 0.2
            threat_indicators += 1
            classification["detected"] = True
        
        # Determine threat level
        if threat_indicators >= 4:
            classification["threat_level"] = "critical"
        elif threat_indicators >= 3:
            classification["threat_level"] = "high"
        elif threat_indicators >= 2:
            classification["threat_level"] = "medium"
        else:
            classification["threat_level"] = "low"
        
        # Determine malware type
        if classification["signatures"]:
            # Use the most confident signature
            best_signature = max(classification["signatures"], key=lambda s: s.confidence)
            classification["type"] = best_signature.malware_type
        elif strings.get("suspicious_strings"):
            # Try to infer type from strings
            suspicious_strings = strings["suspicious_strings"]
            if any("keylog" in s.lower() for s in suspicious_strings):
                classification["type"] = "keylogger"
            elif any("backdoor" in s.lower() for s in suspicious_strings):
                classification["type"] = "backdoor"
            elif any("trojan" in s.lower() for s in suspicious_strings):
                classification["type"] = "trojan"
            else:
                classification["type"] = "trojan"  # Default to trojan
        
        classification["confidence"] = min(confidence_score, 1.0)
        
        return classification
    
    def _generate_recommendations(self, result: MalwareAnalysisResult) -> List[str]:
        """Generate recommendations based on analysis results."""
        recommendations = []
        
        if result.malware_detected:
            recommendations.append("File should be quarantined immediately")
            recommendations.append("Run additional malware scanning tools")
            recommendations.append("Analyze network traffic for related indicators")
            
            if result.threat_level in ["high", "critical"]:
                recommendations.append("Consider incident response procedures")
                recommendations.append("Notify security team immediately")
            
            if result.network_indicators:
                recommendations.append("Monitor network traffic for C2 communications")
                recommendations.append("Block identified network indicators")
            
            if result.registry_indicators:
                recommendations.append("Check registry for persistence mechanisms")
                recommendations.append("Remove any suspicious registry entries")
            
            if result.file_indicators:
                recommendations.append("Scan system for additional malicious files")
                recommendations.append("Check for file system modifications")
        else:
            recommendations.append("File appears clean but continue monitoring")
            recommendations.append("Consider additional analysis if suspicious behavior observed")
        
        return recommendations
    
    def scan_directory(self, directory_path: Union[str, Path], recursive: bool = True) -> List[MalwareAnalysisResult]:
        """Scan directory for malware."""
        results = []
        directory_path = Path(directory_path)
        
        if not directory_path.exists() or not directory_path.is_dir():
            return results
        
        # Get files to scan
        if recursive:
            files = list(directory_path.rglob('*'))
        else:
            files = list(directory_path.iterdir())
        
        # Filter for files only
        files = [f for f in files if f.is_file()]
        
        logger.info(f"🔍 Scanning {len(files)} files in {directory_path}")
        
        for file_path in files:
            try:
                result = self.analyze_file(file_path)
                results.append(result)
                
                if result.malware_detected:
                    logger.warning(f"⚠️ Malware detected: {file_path}")
                
            except Exception as e:
                logger.error(f"❌ Failed to analyze {file_path}: {e}")
        
        # Summary
        malware_count = sum(1 for r in results if r.malware_detected)
        logger.info(f"✅ Scan complete: {malware_count}/{len(results)} files flagged as malware")
        
        return results
    
    def submit_to_vt(self, file_path: Union[str, Path], api_key: str) -> Dict[str, Any]:
        """Submit file to VirusTotal for analysis."""
        try:
            file_path = Path(file_path)
            
            if not file_path.exists():
                raise FileNotFoundError(f"File not found: {file_path}")
            
            # Calculate file hash
            file_hash = self._calculate_file_hash(file_path)
            
            # Check if file was already submitted
            url = f"https://www.virustotal.com/vtapi/v2/file/report"
            params = {
                'apikey': api_key,
                'resource': file_hash
            }
            
            response = requests.get(url, params=params)
            
            if response.status_code == 200:
                result = response.json()
                
                if result['response_code'] == 1:
                    # File found in VirusTotal
                    return {
                        "success": True,
                        "hash": file_hash,
                        "scan_date": result.get('scan_date'),
                        "positives": result.get('positives', 0),
                        "total": result.get('total', 0),
                        "scans": result.get('scans', {}),
                        "permalink": result.get('permalink')
                    }
                else:
                    # File not found, submit for analysis
                    return self._submit_new_file(file_path, api_key)
            else:
                return {
                    "success": False,
                    "error": f"VirusTotal API error: {response.status_code}"
                }
                
        except Exception as e:
            logger.error(f"❌ VirusTotal submission failed: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    def _submit_new_file(self, file_path: Path, api_key: str) -> Dict[str, Any]:
        """Submit new file to VirusTotal."""
        try:
            url = "https://www.virustotal.com/vtapi/v2/file/scan"
            
            with open(file_path, 'rb') as f:
                files = {'file': f}
                data = {'apikey': api_key}
                
                response = requests.post(url, files=files, data=data)
            
            if response.status_code == 200:
                result = response.json()
                return {
                    "success": True,
                    "scan_id": result.get('scan_id'),
                    "message": "File submitted for analysis",
                    "permalink": result.get('permalink')
                }
            else:
                return {
                    "success": False,
                    "error": f"Submission failed: {response.status_code}"
                }
                
        except Exception as e:
            return {
                "success": False,
                "error": str(e)
            }
    
    def cleanup(self):
        """Clean up temporary files."""
        try:
            if self.temp_dir.exists():
                import shutil
                shutil.rmtree(self.temp_dir)
                logger.info("✅ Cleaned up malware analysis temporary files")
        except Exception as e:
            logger.error(f"❌ Failed to cleanup: {e}")

# Example usage and testing
if __name__ == "__main__":
    # Test the malware analysis tools
    mat = MalwareAnalysisTools()
    
    # Create a test file with suspicious content
    test_file = Path("test_malware.exe")
    test_content = b"""
    This is a test file that contains suspicious strings like:
    cmd.exe
    powershell
    download
    execute
    payload
    """
    test_file.write_bytes(test_content)
    
    try:
        # Analyze the test file
        result = mat.analyze_file(test_file)
        
        print(f"✅ Analysis complete:")
        print(f"   Malware detected: {result.malware_detected}")
        print(f"   Malware type: {result.malware_type}")
        print(f"   Threat level: {result.threat_level}")
        print(f"   Confidence: {result.confidence_score}")
        print(f"   Signatures matched: {len(result.signatures_matched)}")
        print(f"   Behavioral indicators: {len(result.behavioral_indicators)}")
        print(f"   Recommendations: {len(result.recommendations)}")
        
    finally:
        # Cleanup
        test_file.unlink(missing_ok=True)
        mat.cleanup()
